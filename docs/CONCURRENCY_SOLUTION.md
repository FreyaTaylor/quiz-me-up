# 并发更新问题解决方案

## 问题描述

### 问题类型
**丢失更新（Lost Update）** / **竞态条件（Race Condition）**

### 问题场景
当两个用户同时提交同一知识点下不同问题的答案时：

```
时间线：
T1: 请求1 提交问题1答案 → 保存 question_record1 → 查询所有记录（只看到 record1）→ 计算平均分 → 更新 mastery
T2: 请求2 提交问题2答案 → 保存 question_record2 → 查询所有记录（只看到 record2）→ 计算平均分 → 更新 mastery

结果：两个请求都基于不完整的数据计算平均分，导致最终掌握度不准确
```

### 具体问题
1. **数据不一致**：两个事务可能基于不同时间点的数据计算平均分
2. **丢失更新**：后执行的更新会覆盖先执行的更新，导致部分数据丢失
3. **计算错误**：平均分计算不准确，遗漏了部分答题记录

## 业界解决方案总结

### 1. 悲观锁（Pessimistic Locking）- ✅ 采用方案

**原理**：在读取数据时加锁，防止其他事务同时修改

**实现方式**：
- `SELECT ... FOR UPDATE`：锁定查询到的记录
- 在事务内执行，事务提交时自动释放锁

**优点**：
- 简单直接，易于理解
- 数据库层面保证，可靠性高
- 适合写多读少的场景

**缺点**：
- 可能造成锁等待，影响并发性能
- 需要合理的事务设计

**适用场景**：
- 需要确保数据一致性的关键操作
- 写操作频繁的场景
- 对一致性要求高的业务

### 2. 乐观锁（Optimistic Locking）

**原理**：假设冲突不常发生，使用版本号或时间戳检测冲突

**实现方式**：
- 添加 `version` 字段
- 更新时检查版本号：`UPDATE ... WHERE version = ?`
- 如果版本号不匹配，更新失败，需要重试

**优点**：
- 并发性能好，无锁等待
- 适合读多写少的场景

**缺点**：
- 需要重试机制
- 可能多次重试才能成功
- 需要额外的版本字段

**适用场景**：
- 读多写少的场景
- 冲突不频繁的业务
- 对性能要求高的场景

### 3. 数据库事务隔离级别

**原理**：通过提高事务隔离级别防止并发问题

**实现方式**：
- `REPEATABLE READ`：可重复读（MySQL 默认）
- `SERIALIZABLE`：串行化（最高隔离级别）

**优点**：
- 数据库层面自动处理
- 无需修改业务代码

**缺点**：
- 可能影响并发性能
- 可能出现死锁
- 隔离级别过高可能影响其他业务

**适用场景**：
- 对一致性要求极高的场景
- 可以接受性能损失的场景

### 4. 应用层同步（Synchronized）

**原理**：使用 Java 的 `synchronized` 关键字或 `ReentrantLock`

**实现方式**：
```java
synchronized (lock) {
    // 更新操作
}
```

**优点**：
- 简单易用
- 无需数据库支持

**缺点**：
- 只适用于单机环境
- 分布式环境下无效
- 可能造成线程阻塞

**适用场景**：
- 单机应用
- 非分布式系统

### 5. 分布式锁（Distributed Lock）

**原理**：使用 Redis、Zookeeper 等实现分布式锁

**实现方式**：
- Redis `SETNX` + 过期时间
- Redisson 分布式锁
- Zookeeper 临时节点

**优点**：
- 适用于分布式环境
- 性能较好

**缺点**：
- 需要额外的中间件
- 实现复杂度较高
- 可能出现死锁或锁超时

**适用场景**：
- 分布式系统
- 微服务架构
- 需要跨服务锁定的场景

### 6. 数据库存储过程/触发器

**原理**：将计算逻辑放在数据库端，利用数据库的原子性

**实现方式**：
- 创建存储过程自动计算平均分
- 使用触发器在插入答题记录时自动更新

**优点**：
- 数据库层面保证原子性
- 减少网络往返

**缺点**：
- 业务逻辑耦合到数据库
- 不利于维护和测试
- 数据库迁移困难

**适用场景**：
- 简单的计算逻辑
- 对性能要求极高的场景

## 本系统采用的解决方案

### 方案：悲观锁（SELECT FOR UPDATE）+ INSERT ... ON DUPLICATE KEY UPDATE

### 实现步骤

1. **使用 SELECT FOR UPDATE 锁定记录**
   ```sql
   SELECT * FROM lc_user_mastery 
   WHERE user_id = ? AND knowledge_id = ? 
   FOR UPDATE
   ```
   - 如果记录存在，锁定该记录
   - 其他事务需要等待当前事务完成

2. **在锁定期间重新查询所有答题记录**
   ```java
   List<QuestionRecord> records = questionRecordMapper.selectByUserIdAndKnowledgeId(userId, knowledgeId);
   ```
   - 确保获取到所有已提交的记录（包括当前事务刚插入的记录）
   - 在事务内，可以看到当前事务的未提交数据

3. **计算平均分**
   ```java
   double avgScore = sumScore / questionCount;
   ```

4. **使用 INSERT ... ON DUPLICATE KEY UPDATE 更新**
   ```sql
   INSERT INTO lc_user_mastery (user_id, knowledge_id, proficiency, updated_at)
   VALUES (?, ?, ?, ?)
   ON DUPLICATE KEY UPDATE
       proficiency = ?,
       updated_at = ?
   ```
   - 如果记录不存在，插入新记录
   - 如果记录已存在，更新记录

### 为什么这个方案有效？

1. **SELECT FOR UPDATE 确保串行化**
   - 同一时间只有一个事务能更新掌握度记录
   - 其他事务需要等待，避免了并发冲突

2. **事务隔离级别保证数据可见性**
   - MySQL 默认 `REPEATABLE READ` 隔离级别
   - 在事务内，可以看到当前事务的所有操作
   - 确保计算时包含当前事务刚插入的答题记录

3. **INSERT ... ON DUPLICATE KEY UPDATE 保证原子性**
   - 即使 SELECT FOR UPDATE 没有锁定记录（记录不存在），
   - INSERT ... ON DUPLICATE KEY UPDATE 也能处理并发插入的情况

### 性能考虑

- **锁等待时间**：通常很短（毫秒级），因为更新操作很快
- **并发性能**：对于同一知识点的更新会串行化，但不同知识点的更新可以并行
- **可扩展性**：方案简单，易于维护和扩展

### 注意事项

1. **事务必须正确使用**
   - `@Transactional` 注解确保方法在事务内执行
   - 事务提交时自动释放锁

2. **避免长事务**
   - 不要在锁定期间执行耗时操作（如调用外部 API）
   - 尽快完成计算和更新

3. **死锁预防**
   - 按固定顺序锁定资源（如先按 user_id，再按 knowledge_id 排序）
   - 本场景中，每个知识点独立锁定，不会出现死锁

## 总结

本系统采用**悲观锁（SELECT FOR UPDATE）**方案，结合**INSERT ... ON DUPLICATE KEY UPDATE**，有效解决了并发更新时的丢失更新问题。这个方案：

- ✅ 简单可靠，易于理解和维护
- ✅ 数据库层面保证，无需额外中间件
- ✅ 适合当前业务场景（写操作频繁，对一致性要求高）
- ✅ 性能可接受（锁等待时间短）

对于未来可能的扩展需求（如分布式部署），可以考虑引入分布式锁（Redis）或消息队列（异步更新）等方案。
